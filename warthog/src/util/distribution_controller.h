#pragma once
#include <cassert>
#include <iostream>
#include <map>
#include <numeric>
#include <ostream>
#include <string>
#include <vector>
#include <tuple>
#include "constants.h"

namespace distribute {
using namespace std;
using namespace warthog;
/* 
DistController generate blocks for a specified worker.
It defines how to distribute tasks to workers
in both preprocessing and query processing stages.
And both stages must use the same DistController.

Concepts:
1. block: a set of nodes, defined by <method, block id>, 
          where "method" defines how to assign nodes to blocks and "block id" defines which block.
          E.g., <mod 10, 1> means put nodes with same "node id % 10" into same block and pick the block with id=1
2. worker: a worker gets a set of blocks, preprocessing and queryprocessing are done by workers, defined by <host, worker id>


How to use:

- init the controller by:
  - n:the number of nodes:
  - maxworker: the total number of workers
  - wid: the id of a worker

auto d = DistController(n, maxworker, wid);

- set the disbutte method:
d.set_method("mod", 10);

- get a block of nodes (in preprocessing):
auto nodes = d.get_block(0);

- write config so that it can be loaded later:
d.write(filename);

- load config from save file, internally it does d.set_method(...) based on config file:
d.load_conf(filename);

- set the get row method (in query processing):
d.set_oracle(oracle)

*/
enum DistributeMethod {
  MOD,
  DIV,
  // not implemented yet
  // RANGE
};

// distribute n nodes based on `div`, return the `bid`-th block
// assuming n nodes in [0, n), bid < maxblock
void gen_div_block(int n, int maxsize, int bid, vector<sn_id_t>& nodes) {
  int from = maxsize * bid;
  int to = min(from + maxsize, n);
  nodes.resize(to - from);
  iota(nodes.begin(), nodes.end(), from);
}

// find x that blocks[bid][x] == nodeid, when blocks is generated by `div`
int get_div_idx(int n, int div, int bid, int nodeid) {
  return nodeid - div * bid;
}

// distribute n nodes based on `mod`, return the `bid`-th block
// maxblock = mod
// assuming n nodes in [0, n), bid < mod
void gen_mod_block(int n, int mod, int bid, vector<sn_id_t>& nodes) {
  nodes.clear();
  for (int i=bid; i<n; i+=mod)
    nodes.push_back(i);
}

// find x that blocks[bid][x] == nodeid, when blocks is generated by `mod`
int get_mod_idx(int n, int mod, int bid, int nodeid) {
  return nodeid / mod;
}

inline string format_cpdfile(string graphfile, string outdir, int wid, int bid) {
  // remove ".xy"
  string res = graphfile.substr(0, graphfile.find_last_of("."));
  if (!outdir.empty()) {
    res = outdir + "/" + res.substr(res.find_last_of("\\/"));
  }
  return res + "-" + to_string(wid) + "-" + to_string(bid) + ".cpd";
}

class DistributeController {

public:
  warthog::sn_id_t n; // total number of nodes
  int distkey,  // <method, distkey> defines how to distribute nodes
      maxworker,// max number of workers, specified by user
      wid,      // woker's id
      maxblock; // max number of blocks, is computed by <method, distkey, n>
  DistributeMethod method;
  vector<tuple<int, int, int>> node2block; // nodeid -> {blockid, index in block}
  vector<vector<sn_id_t>> blocks;      //  node ids of each block
  vector<int> blockids;                // blocks in this worker

  DistributeController() {};
  DistributeController(int _n, int maxw, int _wid): n(_n), maxworker(maxw), wid(_wid) { };

  inline void set_method(string type, int key) {
    if (type == "mod") {
      method = MOD;
    }
    else if (type == "div") {
      method = DIV;
    }
    else {
      cerr << "method not exists" << endl;
      exit(1);
    }
    set_method(method, key);
  }

  inline void set_method(DistributeMethod method, int key) {
    this->method = method;
    this->distkey = key;

    switch (method) {
      case MOD:
        maxblock = key;
        break;
      case DIV:
        maxblock = (n + key - 1) / key;
        break;
      default:
        cerr << "method not exists" << endl;
        exit(1);
        break;
    }
    init();
  }

  inline void init() {
    node2block.resize(n);
    blocks = get_worker_blocks(wid);
  }

  inline vector<sn_id_t> get_block(int bid) {
    vector<sn_id_t> res;
    switch (method) {
      case MOD:
        gen_mod_block(n, maxblock, bid, res);
        break;
      case DIV:
        gen_div_block(n, distkey, bid, res);
        break;
      default:
        cerr << "method not exists" << endl;
        exit(1);
        break;
    }
    return res;
  }

  // what's the index of the nodeid in a block
  inline int get_index_in_block(int nodeid) {
    int res;
    int bid = get_blockid(nodeid);
    switch (method) {
      case MOD:
        res = get_mod_idx(n, distkey, bid, nodeid);
        break;
      case DIV:
        res = get_div_idx(n, distkey, bid, nodeid);
        break;
      default:
        cerr << "method not exists" << endl;
        exit(1);
        break;
    }
    return res;
  }

  // get blocks of any worker
  // assuming #blocks >= #workers
  // every worker get at least ceil(#blocks / #worker) blocks
  // worker in [0, maxworker)
  inline vector<vector<sn_id_t>> get_worker_blocks(int worker) {
    vector<vector<sn_id_t>> res;
    int maxBperW = (maxblock + maxworker - 1) / maxworker;
    int from = maxBperW * worker;
    int to = min(from + maxBperW, maxblock);
    res.clear();
    blockids.resize(to - from);
    // cout << "worker: " << worker << endl;
    for (int i=from; i<to; i++) {
      blockids[i-from] = i;
      res.push_back(get_block(i));
      // cout << "block " << i
      //      << " [ " << *(res.back().begin()) << ", " << res.back().back() << "]" << endl;
      for (auto& id: res.back()) {
        int idinblock = get_index_in_block(id);
        node2block[id] = {i, idinblock, i-from};
      }
    }
    return res;
  }

  // which block has nodeid
  inline int get_blockid(int nodeid) { return get<0>(node2block[nodeid]); }
  // the block index in this worker that contains the node
  inline int get_blockindex(int nodeid) { return get<2>(node2block[nodeid]); }

  // get blocks of this worker (by this->wid)
  inline vector<vector<sn_id_t>>& get_worker_blocks() {
    return blocks;
  }
};

};
